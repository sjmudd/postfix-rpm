Index: src/global/mail_params.h
===================================================================
RCS file: /var/cvs/postfix/src/global/mail_params.h,v
retrieving revision 1.21.2.6
retrieving revision 1.21.2.7
diff -u -r1.21.2.6 -r1.21.2.7
--- src/global/mail_params.h	29 Jul 2002 16:55:54 -0000	1.21.2.6
+++ src/global/mail_params.h	6 Sep 2002 19:54:08 -0000	1.21.2.7
@@ -1359,6 +1359,11 @@
 
 #define WARN_IF_REJECT		"warn_if_reject"
 
+#define REJECT_RBL		"reject_rbl"
+#define VAR_RBL_REPLY_MAPS	"rbl_reply_maps"
+#define DEF_RBL_REPLY_MAPS	""
+extern char *var_rbl_reply_maps;
+
 #define REJECT_MAPS_RBL		"reject_maps_rbl"
 #define VAR_MAPS_RBL_CODE	"maps_rbl_reject_code"
 #define DEF_MAPS_RBL_CODE	554
Index: src/smtpd/smtpd.c
===================================================================
RCS file: /var/cvs/postfix/src/smtpd/smtpd.c,v
retrieving revision 1.5.2.4
retrieving revision 1.5.2.5
diff -u -r1.5.2.4 -r1.5.2.5
--- src/smtpd/smtpd.c	11 Jul 2002 21:09:52 -0000	1.5.2.4
+++ src/smtpd/smtpd.c	6 Sep 2002 19:54:08 -0000	1.5.2.5
@@ -354,6 +354,7 @@
 int     var_maps_rbl_code;
 int     var_access_map_code;
 char   *var_maps_rbl_domains;
+char   *var_rbl_reply_maps;
 int     var_helo_required;
 int     var_reject_code;
 int     var_smtpd_err_sleep;
@@ -1586,6 +1587,7 @@
 	VAR_RCPT_CHECKS, DEF_RCPT_CHECKS, &var_rcpt_checks, 0, 0,
 	VAR_ETRN_CHECKS, DEF_ETRN_CHECKS, &var_etrn_checks, 0, 0,
 	VAR_MAPS_RBL_DOMAINS, DEF_MAPS_RBL_DOMAINS, &var_maps_rbl_domains, 0, 0,
+	VAR_RBL_REPLY_MAPS, DEF_RBL_REPLY_MAPS, &var_rbl_reply_maps, 0, 0,
 	VAR_ALWAYS_BCC, DEF_ALWAYS_BCC, &var_always_bcc, 0, 0,
 	VAR_ERROR_RCPT, DEF_ERROR_RCPT, &var_error_rcpt, 1, 0,
 	VAR_REST_CLASSES, DEF_REST_CLASSES, &var_rest_classes, 0, 0,
Index: src/smtpd/smtpd_check.c
===================================================================
RCS file: /var/cvs/postfix/src/smtpd/smtpd_check.c,v
retrieving revision 1.1.1.15.2.6
retrieving revision 1.1.1.15.2.14
diff -u -r1.1.1.15.2.6 -r1.1.1.15.2.14
--- src/smtpd/smtpd_check.c	11 Jul 2002 21:09:52 -0000	1.1.1.15.2.6
+++ src/smtpd/smtpd_check.c	12 Sep 2002 15:33:02 -0000	1.1.1.15.2.14
@@ -85,12 +85,19 @@
 /* .IP "check_recipient_access maptype:mapname"
 /*	Look up the resolved recipient address in the named access table,
 /*	any parent domains of the recipient domain, and the localpart@.
+/* .IP reject_rbl rbl.domain
+/*	Look up the reversed client network address in the specified
+/*	real-time blackhole DNS zone.  The \fIrbl_reply_maps\fR configuration
+/*	parameter is used to generate the template for the reject message.
+/*	If it is not specified, or the rbl domain cannot be found, then a
+/*	default template is used.  The \fImaps_rbl_reject_code\fR
+/*	configuration parameter specifies the reject status code used in
+/*	the default template (default: 554).
 /* .IP reject_maps_rbl
 /*	Look up the reversed client network address in the real-time blackhole
 /*	DNS zones below the domains listed in the "maps_rbl_domains"
-/*	configuration parameter. The \fImaps_rbl_reject_code\fR
-/*	configuration parameter specifies the reject status code
-/*	(default: 554).
+/*	configuration parameter.  This is equivalent to using "reject_rbl"
+/*	once for each such domain.
 /* .IP permit_naked_ip_address
 /*	Permit the use of a naked IP address (without enclosing [])
 /*	in HELO/EHLO commands.
@@ -271,6 +278,7 @@
 #include <dict.h>
 #include <htable.h>
 #include <ctable.h>
+#include <mac_expand.h>
 
 /* DNS library. */
 
@@ -335,6 +343,11 @@
 static MAPS *relocated_maps;
 
  /*
+  * templates for errors from various rbl domains.
+  */
+static MAPS *rbl_reply_maps;
+
+ /*
   * Pre-opened sender to login name mapping.
   */
 static MAPS *smtpd_sender_login_maps;
@@ -550,6 +563,11 @@
     access_parent_style = match_parent_style(SMTPD_ACCESS_MAPS);
 
     /*
+     * templates for RBL rejection replies
+     */
+    rbl_reply_maps = maps_create(VAR_RBL_REPLY_MAPS, var_rbl_reply_maps,
+				 DICT_FLAG_LOCK);
+    /*
      * Sender to login name mapping.
      */
     smtpd_sender_login_maps = maps_create(VAR_SMTPD_SND_AUTH_MAPS,
@@ -1841,24 +1859,110 @@
     CHECK_MAIL_ACCESS_RETURN(SMTPD_CHECK_DUNNO);
 }
 
-/* reject_maps_rbl - reject if client address in real-time blackhole list */
+typedef struct {
+    SMTPD_STATE *state;
+    VSTRING *rev_addr;
+    const char *domain;
+    const char *txt;
+} RBL_EXP;
 
-static int reject_maps_rbl(SMTPD_STATE *state)
+static const char *rbl_expand_lookup(const char *name, int mode, char *ptr)
 {
-    char   *myname = "reject_maps_rbl";
+    RBL_EXP *rbl = (RBL_EXP *) ptr;
+    SMTPD_STATE *state = rbl->state;
+    char *p;
+    static VSTRING *str = 0;
+    if (!str)
+	str=vstring_alloc(10);
+
+    if (msg_verbose > 1)
+	msg_info("rbl_expand_lookup: $%s",name);
+
+#define STREQ(x,y) (*(x) == *(y) && strcmp((x), (y)) == 0)
+    if (STREQ(name,"client")) {
+	return (state->namaddr);
+    } else if (STREQ(name,"client_address")) {
+	return (state->addr);
+    } else if (STREQ(name,"client_name")) {
+	return (state->name);
+    } else if (STREQ(name,"helo_name")) {
+	return (state->helo_name);
+    } else if (STREQ(name,"sender")) {
+	if (state->sender && *state->sender)
+	    return (state->sender);
+	else
+	    return ("<>");
+    } else if (STREQ(name,"sender_name")) {
+	if (state->sender && *state->sender) {
+	    if (p=strrchr(state->sender,'@')) {
+		vstring_strncpy(str,state->sender,p-state->sender);
+		return (STR(str));
+	    } else {
+		return (state->sender);
+	    }
+	} else
+	    return ("<>");
+    } else if (STREQ(name,"sender_domain")) {
+	if (state->sender && *state->sender) {
+	    if (p=strrchr(state->sender,'@')) {
+		return (p+1);
+	    } else {
+		return ("");
+	    }
+	} else
+	    return ("");
+    } else if (STREQ(name,"recipient")) {
+	if (state->recipient && *state->recipient)
+	    return (state->recipient);
+	else
+	    return ("<>");
+    } else if (STREQ(name,"recipient_name")) {
+	if (state->recipient && *state->recipient) {
+	    if (p=strrchr(state->recipient,'@')) {
+		vstring_strncpy(str,state->recipient,p-state->recipient);
+		return (STR(str));
+	    } else {
+		return (state->recipient);
+	    }
+	} else
+	    return ("<>");
+    } else if (STREQ(name,"recipient_domain")) {
+	if (state->recipient && *state->recipient) {
+	    if (p=strrchr(state->recipient,'@')) {
+		return (p+1);
+	    } else {
+		return ("");
+	    }
+	} else
+	    return ("");
+    } else if (STREQ(name,"rbl_code")) {
+	vstring_sprintf(str,"%d",var_maps_rbl_code);
+	return (STR(str));
+    } else if (STREQ(name,"rbl_address")) {
+	return(STR(rbl->rev_addr));
+    } else if (STREQ(name,"rbl_domain")) {
+	return (rbl->domain);
+    } else if (STREQ(name,"rbl_txt")) {
+	return (rbl->txt);
+    } else {
+	return (0);
+    }
+}
+
+/* reject_rbl - reject if client address in real-time blackhole list */
+
+static int reject_rbl(SMTPD_STATE *state, const char *rbl_domain)
+{
+    char   *myname = "reject_rbl";
     ARGV   *octets = argv_split(state->addr, ".");
     VSTRING *query = vstring_alloc(100);
-    char   *saved_domains = mystrdup(var_maps_rbl_domains);
-    char   *bp = saved_domains;
-    char   *rbl_domain;
-    char   *rbl_reason;
-    char   *rbl_fodder;
     DNS_RR *txt_list;
     int     reverse_len;
-    int     dns_status = DNS_FAIL;
+    int     dns_status;
     int     i;
     int     result;
-    VSTRING *why;
+    VSTRING *why=vstring_alloc(10);
+    const char *template=0;
 
     if (msg_verbose)
 	msg_info("%s: %s", myname, state->addr);
@@ -1878,51 +1982,92 @@
 	vstring_strcat(query, octets->argv[i]);
 	vstring_strcat(query, ".");
     }
+    argv_free(octets);
     reverse_len = VSTRING_LEN(query);
 
     /*
-     * Tack on each RBL domain name and query the DNS for an A record. If the
+     * Tack on the RBL domain name and query the DNS for an A record. If the
      * record exists, the client address is blacklisted.
      */
-    why = vstring_alloc(10);
-    while ((rbl_domain = mystrtok(&bp, " \t\r\n,")) != 0) {
-	vstring_truncate(query, reverse_len);
-	vstring_strcat(query, rbl_domain);
-	dns_status = dns_lookup(STR(query), T_A, 0, (DNS_RR **) 0,
-				(VSTRING *) 0, why);
-	if (dns_status == DNS_OK)
-	    break;
-	if (dns_status != DNS_NOTFOUND)
-	    msg_warn("%s: RBL lookup error: %s", STR(query), STR(why));
-    }
-    vstring_free(why);
+    vstring_truncate(query, reverse_len);
+    vstring_strcat(query, rbl_domain);
+    dns_status = dns_lookup(STR(query), T_A, 0, (DNS_RR **) 0,
+			    (VSTRING *) 0, why);
+    if (dns_status != DNS_OK && dns_status != DNS_NOTFOUND)
+	msg_warn("%s: RBL lookup error: %s", STR(query), STR(why));
 
     /*
      * Report the result.
      */
     if (dns_status == DNS_OK) {
+	RBL_EXP rbl;
+	rbl.state = state;
+	rbl.domain = rbl_domain;
+	rbl.rev_addr = vstring_alloc(10);
+	vstring_strncpy(rbl.rev_addr,STR(query),reverse_len-1);
 	if (dns_lookup(STR(query), T_TXT, 0, &txt_list,
 		       (VSTRING *) 0, (VSTRING *) 0) == DNS_OK) {
-	    rbl_fodder = ", reason: ";
-	    rbl_reason = (char *) txt_list->data;
+	    rbl.txt = txt_list->data;
 	} else {
 	    txt_list = 0;
-	    rbl_fodder = rbl_reason = "";
+	    rbl.txt = "";
 	}
-	result = smtpd_check_reject(state, MAIL_ERROR_POLICY,
+	if (*var_rbl_reply_maps) {
+	    DICT   *dict;
+	    char   *low_name = lowercase(mystrdup(rbl_domain));
+	    template = maps_find(rbl_reply_maps, low_name, 0);
+	    myfree(low_name);
+	}
+	if (template && mac_expand(why, template, MAC_EXP_FLAG_NONE, NULL, 
+				   rbl_expand_lookup, (char *) &rbl)) {
+	    msg_warn("%s: bad rbl template: %s",myname,template);
+	    template = 0;	/* pretend we couldn't find one it */
+	}
+	if (template) {
+	    result = smtpd_check_reject(state, MAIL_ERROR_POLICY, STR(why));
+	} else {
+	    result = smtpd_check_reject(state, MAIL_ERROR_POLICY,
 			"%d Service unavailable; [%s] blocked using %s%s%s",
-				 var_maps_rbl_code, state->addr, rbl_domain,
-				    rbl_fodder, rbl_reason);
+				 var_maps_rbl_code, state->addr,
+				 rbl_domain, txt_list ? ", reason: " : "", rbl.txt);
+	}
 	if (txt_list)
 	    dns_rr_free(txt_list);
+	vstring_free(rbl.rev_addr);
     } else
 	result = SMTPD_CHECK_DUNNO;
 
     /*
      * Clean up.
      */
-    argv_free(octets);
     vstring_free(query);
+    vstring_free(why);
+
+    return (result);
+}
+
+/* reject_maps_rbl - reject if client address in real-time blackhole list */
+
+static int reject_maps_rbl(SMTPD_STATE *state)
+{
+    char   *myname = "reject_maps_rbl";
+    char   *saved_domains = mystrdup(var_maps_rbl_domains);
+    char   *bp = saved_domains;
+    char   *rbl_domain;
+    int     result;
+
+    if (msg_verbose)
+	msg_info("%s: %s", myname, state->addr);
+
+    while ((rbl_domain = mystrtok(&bp, " \t\r\n,")) != 0) {
+	result = reject_rbl(state,rbl_domain);
+	if (result != SMTPD_CHECK_DUNNO)
+	    break;
+    }
+
+    /*
+     * Clean up.
+     */
     myfree(saved_domains);
 
     return (result);
@@ -2059,6 +2204,8 @@
 					 SMTPD_NAME_CLIENT, def_acl);
 	} else if (strcasecmp(name, REJECT_MAPS_RBL) == 0) {
 	    status = reject_maps_rbl(state);
+	} else if (strcasecmp(name, REJECT_RBL) == 0) {
+	    status = reject_rbl(state,*(cpp+=1));
 	}
 
 	/*
