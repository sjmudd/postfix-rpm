--- snapshot-20010228-orig/src/flush/flush.c	Sun Jan 28 16:26:18 2001
+++ snapshot-20010228/src/flush/flush.c		Fri Mar 30 00:19:34 2001
@@ -129,6 +129,8 @@
 #include <stdlib.h>
 #include <utime.h>
 #include <errno.h>
+#include <ctype.h>
+#include <string.h>
 
 /* Utility library. */
 
@@ -138,7 +140,6 @@
 #include <vstring.h>
 #include <vstring_vstream.h>
 #include <myflock.h>
-#include <valid_hostname.h>
 #include <htable.h>
 #include <dict.h>
 #include <scan_dir.h>
@@ -163,7 +164,9 @@
 /* Application-specific. */
 
  /*
-  * Tunable parameters.
+  * Tunable parameters. The fast_flush_domains parameter is not defined here,
+  * because it is also used by the global library, and therefore is owned by
+  * the library.
   */
 int     var_fflush_refresh;
 int     var_fflush_purge;
@@ -175,17 +178,52 @@
 
  /*
   * Some hard-wired policy: how many queue IDs we remember while we're
-  * flushing a logfile.
+  * flushing a logfile (duplicate elimination). Sites with 1000+ emails
+  * queued should arrange for permanent connectivity.
   */
 #define FLUSH_DUP_FILTER_SIZE	10000	/* graceful degradation */
 
  /*
   * Silly little macros.
   */
-
 #define STR(x)			vstring_str(x)
 #define STREQ(x,y)		(strcmp(x,y) == 0)
 
+ /*
+  * Forward declarations resulting from breaking up routines according to
+  * name space: domain names versus safe-to-use pathnames.
+  */
+static int flush_add_path(const char *, const char *);
+static int flush_send_path(const char *);
+
+/* flush_site_to_path - convert domain or [addr] to harmless string */
+
+static VSTRING *flush_site_to_path(VSTRING *path, const char *site)
+{
+    int     ch;
+
+    /*
+     * Allocate buffer on the fly; caller still needs to clean up.
+     */
+    if (path == 0)
+	path = vstring_alloc(10);
+
+    /*
+     * Mask characters that could upset the name-to-queue-file mapping code.
+     */
+    while ((ch = *(unsigned const char *) site++) != 0)
+	if (ISALNUM(ch))
+	    VSTRING_ADDCH(path, ch);
+	else
+	    VSTRING_ADDCH(path, '_');
+    VSTRING_TERMINATE(path);
+
+    if (msg_verbose)
+	msg_info("site %s to path %s", site, STR(path));
+
+    return (path);
+}
+
 /* flush_policy_ok - check logging policy */
 
 static int flush_policy_ok(const char *site)
@@ -193,12 +231,13 @@
     return (domain_list_match(flush_domains, site));
 }
 
-/* flush_add_service - append queue ID to per-site fast flush log */
+/* flush_add_service - append queue ID to per-site fast flush logfile */
 
 static int flush_add_service(const char *site, const char *queue_id)
 {
     char   *myname = "flush_add_service";
-    VSTREAM *log;
+    VSTRING *site_path;
+    int     status;
 
     if (msg_verbose)
 	msg_info("%s: site %s queue_id %s", myname, site, queue_id);
@@ -210,12 +249,34 @@
 	return (FLUSH_STAT_OK);
 
     /*
+     * Map site to path and update log.
+     */
+    site_path = flush_site_to_path((VSTRING *) 0, site);
+    status = flush_add_path(STR(site_path), queue_id);
+    vstring_free(site_path);
+
+    return (status);
+}
+
+/* flush_add_path - add record to log */
+
+static int flush_add_path(const char *path, const char *queue_id)
+{
+    char   *myname = "flush_add_path";
+    VSTREAM *log;
+
+    /*
+     * Sanity check.
+     */
+    if (!mail_queue_id_ok(path))
+	return (FLUSH_STAT_BAD);
+
+    /*
      * Open the logfile or bust.
      */
-    if ((log = mail_queue_open(MAIL_QUEUE_FLUSH, site,
+    if ((log = mail_queue_open(MAIL_QUEUE_FLUSH, path,
 			       O_CREAT | O_APPEND | O_WRONLY, 0600)) == 0)
-	msg_fatal("%s: open fast flush log for site %s: %m",
-		  myname, site);
+	msg_fatal("%s: open fast flush logfile %s: %m", myname, path);
 
     /*
      * We must lock the logfile, so that we don't lose information due to
@@ -223,24 +284,25 @@
      * will eventually take care of the problem, but it will take a while.
      */
     if (myflock(vstream_fileno(log), INTERNAL_LOCK, MYFLOCK_OP_EXCLUSIVE) < 0)
-	msg_fatal("%s: lock fast flush log for site %s: %m", myname, site);
+	msg_fatal("%s: lock fast flush logfile %s: %m", myname, path);
 
     /*
-     * Append the queue ID. With 15 bits if microsecond time, a queue ID is
+     * Append the queue ID. With 15 bits of microsecond time, a queue ID is
      * not recycled often enough for false hits to be a problem. If it does,
      * then we could add other signature information, such as the file size
      * in bytes.
      */
     vstream_fprintf(log, "%s\n", queue_id);
+    if (vstream_fflush(log))
+	msg_warn("write fast flush logfile %s: %m", path);
 
     /*
      * Clean up.
      */
     if (myflock(vstream_fileno(log), INTERNAL_LOCK, MYFLOCK_OP_NONE) < 0)
-	msg_fatal("%s: unlock fast flush log for site %s: %m",
-		  myname, site);
+	msg_fatal("%s: unlock fast flush logfile %s: %m", myname, path);
     if (vstream_fclose(log) != 0)
-	msg_warn("write fast flush log for site %s: %m", site);
+	msg_warn("write fast flush logfile %s: %m", path);
 
     return (FLUSH_STAT_OK);
 }
@@ -250,6 +312,33 @@
 static int flush_send_service(const char *site)
 {
     char   *myname = "flush_send_service";
+    VSTRING *site_path;
+    int     status;
+
+    if (msg_verbose)
+	msg_info("%s: site %s", myname, site);
+
+    /*
+     * If this site is not eligible for logging, deliver all queued mail.
+     */
+    if (flush_policy_ok(site) == 0)
+	return (mail_flush_deferred());
+
+    /*
+     * Map site name to path name and flush the log.
+     */
+    site_path = flush_site_to_path((VSTRING *) 0, site);
+    status = flush_send_path(STR(site_path));
+    vstring_free(site_path);
+
+    return (status);
+}
+
+/* flush_send_path - flush logfile file */
+
+static int flush_send_path(const char *path)
+{
+    const char *myname = "flush_send_path";
     VSTRING *queue_id;
     VSTRING *queue_file;
     VSTREAM *log;
@@ -261,22 +350,19 @@
     HTABLE *dup_filter;
     int     count;
 
-    if (msg_verbose)
-	msg_info("%s: site %s", myname, site);
-
     /*
-     * If this site is not eligible for logging, deliver all queued mail.
+     * Sanity check.
      */
-    if (flush_policy_ok(site) == 0)
-	return (mail_flush_deferred());
+    if (!mail_queue_id_ok(path))
+	return (FLUSH_STAT_BAD);
 
     /*
      * Open the logfile. If the file does not exist, then there is no queued
      * mail for this destination.
      */
-    if ((log = mail_queue_open(MAIL_QUEUE_FLUSH, site, O_RDWR, 0600)) == 0) {
+    if ((log = mail_queue_open(MAIL_QUEUE_FLUSH, path, O_RDWR, 0600)) == 0) {
 	if (errno != ENOENT)
-	    msg_fatal("%s: open fast flush log for site %s: %m", myname, site);
+	    msg_fatal("%s: open fast flush logfile %s: %m", myname, path);
 	return (FLUSH_STAT_OK);
     }
 
@@ -287,7 +373,7 @@
      * watchdog will take care of it.
      */
     if (myflock(vstream_fileno(log), INTERNAL_LOCK, MYFLOCK_OP_EXCLUSIVE) < 0)
-	msg_fatal("%s: lock fast flush log for site %s: %m", myname, site);
+	msg_fatal("%s: lock fast flush logfile %s: %m", myname, path);
 
     /*
      * This is the part that dominates running time: schedule the listed
@@ -312,15 +398,15 @@
     tbuf.actime = tbuf.modtime = event_time();
     for (count = 0; vstring_get_nonl(queue_id, log) != VSTREAM_EOF; count++) {
 	if (!mail_queue_id_ok(STR(queue_id))) {
-	    msg_warn("bad queue id \"%.30s...\" in fast flush log for site %s",
-		     STR(queue_id), site);
+	    msg_warn("bad queue id \"%.30s...\" in fast flush logfile %s",
+		     STR(queue_id), path);
 	    continue;
 	}
 	if (dup_filter->used >= FLUSH_DUP_FILTER_SIZE
 	    || htable_find(dup_filter, STR(queue_id)) == 0) {
 	    if (msg_verbose)
-		msg_info("%s: site %s: update %s time stamps",
-			 myname, site, STR(queue_id));
+		msg_info("%s: logfile %s: update queue file %s time stamps",
+			 myname, path, STR(queue_id));
 	    if (dup_filter->used <= FLUSH_DUP_FILTER_SIZE)
 		htable_enter(dup_filter, STR(queue_id), 0);
 
@@ -344,8 +430,8 @@
 	    }
 	} else {
 	    if (msg_verbose)
-		msg_info("%s: site %s: skip file %s as duplicate",
-			 myname, site, STR(queue_file));
+		msg_info("%s: logfile %s: skip queue file %s as duplicate",
+			 myname, path, STR(queue_file));
 	}
     }
     htable_free(dup_filter, (void (*) (char *)) 0);
@@ -356,19 +442,18 @@
      * Truncate the fast flush log.
      */
     if (count > 0 && ftruncate(vstream_fileno(log), (off_t) 0) < 0)
-	msg_fatal("%s: truncate fast flush log for site %s: %m", myname, site);
+	msg_fatal("%s: truncate fast flush logfile %s: %m", myname, path);
 
     /*
      * Request delivery and clean up.
      */
     if (myflock(vstream_fileno(log), INTERNAL_LOCK, MYFLOCK_OP_NONE) < 0)
-	msg_fatal("%s: unlock fast flush log for site %s: %m",
-		  myname, site);
+	msg_fatal("%s: unlock fast flush logfile %s: %m", myname, path);
     if (vstream_fclose(log) != 0)
-	msg_warn("read fast flush log for site %s: %m", site);
+	msg_warn("%s: read fast flush logfile %s: %m", myname, path);
     if (count > 0) {
 	if (msg_verbose)
-	    msg_info("%s: requesting delivery for site %s", myname, site);
+	    msg_info("%s: requesting delivery for logfile %s", myname, path);
 	mail_trigger(MAIL_CLASS_PUBLIC, MAIL_SERVICE_QUEUE,
 		     qmgr_trigger, sizeof(qmgr_trigger));
     }
@@ -381,23 +466,15 @@
 {
     char   *myname = "flush_refresh_service";
     SCAN_DIR *scan;
-    char   *site;
+    char   *site_path;
     struct stat st;
     VSTRING *path = vstring_alloc(10);
 
     scan = scan_dir_open(MAIL_QUEUE_FLUSH);
-    while ((site = mail_scan_dir_next(scan)) != 0) {
-	if (!mail_queue_id_ok(site))
+    while ((site_path = mail_scan_dir_next(scan)) != 0) {
+	if (!mail_queue_id_ok(site_path))
 	    continue;				/* XXX grumble. */
-	mail_queue_path(path, MAIL_QUEUE_FLUSH, site);
-	if (flush_policy_ok(site) == 0) {
-	    if (unlink(STR(path)) < 0)
-		msg_warn("remove %s: %m", STR(path));
-	    else if (msg_verbose)
-		msg_info("%s: spurious fast flush logfile name: %s",
-			 myname, site);
-	    continue;
-	}
+	mail_queue_path(path, MAIL_QUEUE_FLUSH, site_path);
 	if (stat(STR(path), &st) < 0) {
 	    if (errno != ENOENT)
 		msg_warn("%s: stat %s: %m", myname, STR(path));
@@ -408,20 +485,20 @@
 	if (st.st_size == 0) {
 	    if (st.st_mtime + var_fflush_purge < event_time()) {
 		if (unlink(STR(path)) < 0)
-		    msg_warn("remove %s: %m", STR(path));
+		    msg_warn("remove logfile %s: %m", STR(path));
 		else if (msg_verbose)
 		    msg_info("%s: unlink %s, empty and unchanged for %d days",
 			     myname, STR(path), var_fflush_purge / 86400);
 	    } else if (msg_verbose)
-		msg_info("%s: skip site %s - empty log", myname, site);
+		msg_info("%s: skip logfile %s - empty log", myname, site_path);
 	} else if (st.st_atime + max_age < event_time()) {
 	    if (msg_verbose)
-		msg_info("%s: flush site %s", myname, site);
-	    flush_send_service(site);
+		msg_info("%s: flush logfile %s", myname, site_path);
+	    flush_send_path(site_path);
 	} else {
 	    if (msg_verbose)
-		msg_info("%s: skip site %s, unread for <%d hours(s) ",
-			 myname, site, max_age / 3600);
+		msg_info("%s: skip logfile %s, unread for <%d hours(s) ",
+			 myname, site_path, max_age / 3600);
 	}
     }
     scan_dir_close(scan);
@@ -454,9 +531,7 @@
      * This routine runs whenever a client connects to the UNIX-domain socket
      * dedicated to the fast flush service. What we see below is a little
      * protocol to (1) read a request from the client (the name of the site)
-     * and (2) acknowledge that we have received the request. Since the site
-     * name maps onto the file system, make sure the site name is a valid
-     * SMTP hostname.
+     * and (2) acknowledge that we have received the request.
      * 
      * All connection-management stuff is handled by the common code in
      * single_server.c.
@@ -466,14 +541,12 @@
 	    site = vstring_alloc(10);
 	    queue_id = vstring_alloc(10);
 	    if (mail_command_read(client_stream, "%s %s", site, queue_id) == 2
-		&& valid_hostname(STR(site), DONT_GRIPE)
 		&& mail_queue_id_ok(STR(queue_id)))
 		status = flush_add_service(lowercase(STR(site)), STR(queue_id));
 	    mail_print(client_stream, "%d", status);
 	} else if (STREQ(STR(request), FLUSH_REQ_SEND)) {
 	    site = vstring_alloc(10);
-	    if (mail_command_read(client_stream, "%s", site) == 1
-		&& valid_hostname(STR(site), DONT_GRIPE))
+	    if (mail_command_read(client_stream, "%s", site) == 1)
 		status = flush_send_service(lowercase(STR(site)));
 	    mail_print(client_stream, "%d", status);
 	} else if (STREQ(STR(request), FLUSH_REQ_REFRESH)
