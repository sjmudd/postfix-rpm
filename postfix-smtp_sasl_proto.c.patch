*** snapshot-20010502/src/smtp/smtp_sasl_proto.c-	Tue May 22 14:27:06 2001
--- snapshot-20010502/src/smtp/smtp_sasl_proto.c	Fri May 25 13:30:02 2001
***************
*** 77,97 ****
  
  void    smtp_sasl_helo_auth(SMTP_STATE *state, const char *words)
  {
  
      /*
       * XXX If the server offers a null list of authentication mechanisms,
       * then pretend that the server doesn't support SASL authentication.
       */
      if (state->sasl_mechanism_list) {
  	if (strcasecmp(state->sasl_mechanism_list, words) == 0)
  	    return;
  	myfree(state->sasl_mechanism_list);
! 	msg_warn("%s offered AUTH option multiple times",
! 		 state->session->namaddr);
! 	state->sasl_mechanism_list = 0;
! 	state->features &= ~SMTP_FEATURE_AUTH;
!     }
!     if (strlen(words) > 0) {
  	state->sasl_mechanism_list = mystrdup(words);
  	state->features |= SMTP_FEATURE_AUTH;
      } else {
--- 77,99 ----
  
  void    smtp_sasl_helo_auth(SMTP_STATE *state, const char *words)
  {
+     char   *cp;
  
      /*
       * XXX If the server offers a null list of authentication mechanisms,
       * then pretend that the server doesn't support SASL authentication.
+      * 
+      * XXX Some servers offer AUTH multiple times, with different lists of
+      * methods. We could try to be clever and compute unions of those lists,
+      * but simple concatenation may do the job.
       */
      if (state->sasl_mechanism_list) {
  	if (strcasecmp(state->sasl_mechanism_list, words) == 0)
  	    return;
+ 	cp = contatenate(state->sasl_mechanism_list, " ", words);
  	myfree(state->sasl_mechanism_list);
! 	state->sasl_mechanism_list = cp;
!     } else if (strlen(words) > 0) {
  	state->sasl_mechanism_list = mystrdup(words);
  	state->features |= SMTP_FEATURE_AUTH;
      } else {
